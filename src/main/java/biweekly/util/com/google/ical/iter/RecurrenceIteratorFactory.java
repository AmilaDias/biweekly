// Copyright (C) 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package biweekly.util.com.google.ical.iter;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import biweekly.util.ByDay;
import biweekly.util.DayOfWeek;
import biweekly.util.com.google.ical.util.Predicate;
import biweekly.util.com.google.ical.util.Predicates;
import biweekly.util.com.google.ical.util.TimeUtils;
import biweekly.util.com.google.ical.values.DateTimeValue;
import biweekly.util.com.google.ical.values.DateTimeValueImpl;
import biweekly.util.com.google.ical.values.DateValue;
import biweekly.util.com.google.ical.values.DateValueImpl;
import biweekly.util.com.google.ical.values.Frequency;
import biweekly.util.com.google.ical.values.IcalObject;
import biweekly.util.com.google.ical.values.RDateList;
import biweekly.util.com.google.ical.values.RRule;
import biweekly.util.com.google.ical.values.TimeValue;

/**
 * <p>
 * Calculates the occurrences of an individual RRULE definition or groups of
 * RRULEs, RDATEs, EXRULEs, and EXDATEs.
 * </p>
 * <p>
 * <b>Glossary</b>
 * </p>
 * <ul>
 * <li>Period - year|month|day|...</li>
 * <li>Day of the week - an int in [0,6]</li>
 * <li>Day of the year - zero indexed in [0,365]</li>
 * <li>Day of the month - 1 indexed in [1,31]</li>
 * <li>Month - 1 indexed integer in [1,12]</li>
 * </ul>
 * <p>
 * <b>Abstractions</b>
 * </p>
 * <ul>
 * <li>Generator - a function corresponding to an RRULE part that takes a date
 * and returns a later (year or month or day depending on its period) within the
 * next larger period. A generator ignores all periods in its input smaller than
 * its period.</li>
 * <li>Filter - a function that returns true iff the given date matches the
 * subrule.</li>
 * <li>Condition - returns true if the given date is past the end of the
 * recurrence.</li>
 * </ul>
 * <p>
 * All the functions that represent rule parts are stateful.
 * </p>
 * @author mikesamuel+svn@gmail.com (Mike Samuel)
 */
public class RecurrenceIteratorFactory {

  private static final Logger LOGGER = Logger.getLogger(
      RecurrenceIteratorFactory.class.getName());

  /**
   * given a block of RRULE, EXRULE, RDATE, and EXDATE content lines, parse
   * them into a single recurrence iterator.
   * @param rdata ical text.
   * @param dtStart the date of the first occurrence in timezone tzid, which is
   *   used to fill in optional fields in the RRULE, such as the day of the
   *   month for a monthly repetition when no ther day specified.
   *   Note: this may not be the first date in the series since an EXRULE or
   *     EXDATE might force it to be skipped, but there will be no earlier date
   *     generated by this ruleset.
   * @param strict true if any failure to parse should result in a
   *   ParseException.  false causes bad content lines to be logged and ignored.
   */
  public static RecurrenceIterator createRecurrenceIterator(
      String rdata, DateValue dtStart, TimeZone tzid, boolean strict)
      throws ParseException {
    return createRecurrenceIterable(rdata, dtStart, tzid, strict).iterator();
  }

  public static RecurrenceIterable createRecurrenceIterable(
      String rdata, final DateValue dtStart, final TimeZone tzid,
      final boolean strict)
      throws ParseException {
    final IcalObject[] contentLines = parseContentLines(rdata, tzid, strict);

    return new RecurrenceIterable() {
        public RecurrenceIterator iterator() {
          List<RecurrenceIterator> inclusions =
               new ArrayList<RecurrenceIterator>();
          List<RecurrenceIterator> exclusions =
               new ArrayList<RecurrenceIterator>();
          // always include DTStart
          inclusions.add(new RDateIteratorImpl(
                             new DateValue[] {TimeUtils.toUtc(dtStart, tzid)}));
          for (IcalObject contentLine : contentLines) {
            try {
              String name = contentLine.getName();
              if ("rrule".equalsIgnoreCase(name)) {
                inclusions.add(createRecurrenceIterator(
                                   (RRule) contentLine, dtStart, tzid));
              } else if ("rdate".equalsIgnoreCase(name)) {
                inclusions.add(
                    createRecurrenceIterator((RDateList) contentLine));
              } else if ("exrule".equalsIgnoreCase(name)) {
                exclusions.add(createRecurrenceIterator(
                                   (RRule) contentLine, dtStart, tzid));
              } else if ("exdate".equalsIgnoreCase(name)) {
                exclusions.add(
                    createRecurrenceIterator((RDateList) contentLine));
              }
            } catch (IllegalArgumentException ex) {
              // bad frequency on rrule or exrule
              if (strict) { throw ex; }
              LOGGER.log(
                  Level.SEVERE,
                  "Dropping bad recurrence rule line: " + contentLine.toIcal(),
                  ex);
            }
          }
          return new CompoundIteratorImpl(inclusions, exclusions);
        }
      };
  }

  /**
   * like {@link #createRecurrenceIterator(String,DateValue,TimeZone,boolean)}
   * but defaults to strict parsing.
   */
  public static RecurrenceIterator createRecurrenceIterator(
      String rdata, DateValue dtStart, TimeZone tzid)
      throws ParseException {
    return createRecurrenceIterator(rdata, dtStart, tzid, true);
  }

  /**
   * Creates a recurrence iterator from an RDATE or EXDATE list.
   * @param rdates the list
   * @return the iterator
   */
  public static RecurrenceIterator createRecurrenceIterator(RDateList rdates) {
    DateValue[] dates = rdates.getDatesUtc();
    return new RDateIteratorImpl(dates);
  }

  /**
   * Creates a recurrence iterator from an RRULE.
   * @param rrule the recurrence rule
   * @param dtStart the start date of the series
   * @param tzid the timezone that the given start date is in
   * @return the iterator
   */
  public static RecurrenceIterator createRecurrenceIterator(
      RRule rrule, DateValue dtStart, TimeZone tzid) {
    Frequency freq = rrule.getFreq();
    DayOfWeek wkst = rrule.getWkSt();
    DateValue untilUtc = rrule.getUntil();
    int count = rrule.getCount();
    int interval = rrule.getInterval();
    ByDay[] byDay = rrule.getByDay().toArray(new ByDay[0]);
    int[] byMonth = rrule.getByMonth();
    int[] byMonthDay = rrule.getByMonthDay();
    int[] byWeekNo = rrule.getByWeekNo();
    int[] byYearDay = rrule.getByYearDay();
    int[] bySetPos = rrule.getBySetPos();
    int[] byHour = rrule.getByHour();
    int[] byMinute = rrule.getByMinute();
    int[] bySecond = rrule.getBySecond();

    if (interval <= 0) {  interval = 1; }

    if (wkst == null) {
      wkst = DayOfWeek.MONDAY;
    }

    //optimize out BYSETPOS where possible
    if (bySetPos.length > 0) {
      switch (freq) {
        case HOURLY:
          if (byHour.length > 0 && byMinute.length <= 1
              && bySecond.length <= 1) {
            byHour = filterBySetPos(byHour, bySetPos);
          }
          
          /*
           * Handling bySetPos for rules that are more frequent than daily tends
           * to lead to large amounts of processor being used before other work
           * limiting features can kick in since there many seconds between
           * dtStart and where the year limit kicks in. There are no known use
           * cases for the use of bySetPos with hourly minutely and secondly rules
           * so we just ignore it.
           */
          bySetPos = NO_INTS;
          break;
        case MINUTELY:
          if (byMinute.length > 0 && bySecond.length <= 1) {
            byMinute = filterBySetPos(byMinute, bySetPos);
          }
          //see bySetPos handling comment above
          bySetPos = NO_INTS;
          break;
        case SECONDLY:
          if (bySecond.length > 0) {
            bySecond = filterBySetPos(bySecond, bySetPos);
          }
          //see bySetPos handling comment above
          bySetPos = NO_INTS;
          break;
        default:
      }
    }

    DateValue start = dtStart;
    if (bySetPos.length > 0) {
      /*
       * Roll back until the beginning of the period to make sure that any
       * positive indices are indexed properly. The actual iterator
       * implementation is responsible for anything < dtStart.
       */
      switch (freq) {
        case YEARLY:
          start = dtStart instanceof TimeValue
              ? new DateTimeValueImpl(start.year(), 1, 1, 0, 0, 0)
              : new DateValueImpl(start.year(), 1, 1);
          break;
        case MONTHLY:
          start = dtStart instanceof TimeValue
              ? new DateTimeValueImpl(start.year(), start.month(), 1, 0, 0, 0)
              : new DateValueImpl(start.year(), start.month(), 1);
          break;
        case WEEKLY:
          int d = (7 + wkst.ordinal() - TimeUtils.dayOfWeek(dtStart).getCalendarConstant()) % 7;
          start = TimeUtils.add(dtStart, new DateValueImpl(0, 0, -d));
          break;
        default: break;
      }
    }

    /*
     * Recurrences are implemented as a sequence of periodic generators. First a
     * year is generated, and then months, and within months, days.
     */
    ThrottledGenerator yearGenerator = Generators.serialYearGenerator(
        freq == Frequency.YEARLY ? interval : 1, dtStart);
    Generator monthGenerator = null;
    Generator dayGenerator = null;
    Generator secondGenerator = null;
    Generator minuteGenerator = null;
    Generator hourGenerator = null;

    /*
     * When multiple generators are specified for a period, they act as a union
     * operator. We could have multiple generators (say, for day) and then run
     * each and merge the results, but some generators are more efficient than
     * others. So to avoid generating 53 Sundays and throwing away all but 1 for
     * RRULE:FREQ=YEARLY;BYDAY=TU;BYWEEKNO=1, we reimplement some of the more
     * prolific generators as filters.
     */
    // TODO(msamuel): don't need a list here
    List<Predicate<? super DateValue>> filters =
      new ArrayList<Predicate<? super DateValue>>();

    switch (freq) {
      case SECONDLY:
        if (bySecond.length == 0 || interval != 1) {
          secondGenerator = Generators.serialSecondGenerator(interval, dtStart);
          if (bySecond.length > 0) {
            filters.add(Filters.bySecondFilter(bySecond));
          }
        }
        break;
      case MINUTELY:
        if (byMinute.length == 0 || interval != 1) {
          minuteGenerator = Generators.serialMinuteGenerator(interval, dtStart);
          if (byMinute.length > 0) {
            filters.add(Filters.byMinuteFilter(byMinute));
          }
        }
        break;
      case HOURLY:
        if (byHour.length == 0 || interval != 1) {
          hourGenerator = Generators.serialHourGenerator(interval, dtStart);
          if (byHour.length > 0) {
            filters.add(Filters.byHourFilter(bySecond));
          }
        }
        break;
      case DAILY:
        break;
      case WEEKLY:
        /*
         * Week is not considered a period because a week may span multiple months
         * and/or years. There are no week generators, so a filter is used to make
         * sure that FREQ=WEEKLY;INTERVAL=2 only generates dates within the proper
         * week.
         */
        if (byDay.length > 0) {
          dayGenerator = Generators.byDayGenerator(byDay, false, start);
          byDay = NO_DAYS;
          if (interval > 1) {
            filters.add(Filters.weekIntervalFilter(interval, wkst, dtStart));
          }
        } else {
          dayGenerator = Generators.serialDayGenerator(interval * 7, dtStart);
        }
        break;
      case YEARLY:
        if (byYearDay.length > 0) {
          /*
           * The BYYEARDAY rule part specifies a COMMA separated list of days of
           * the year. Valid values are 1 to 366 or -366 to -1. For example, -1
           * represents the last day of the year (December 31st) and -306
           * represents the 306th to the last day of the year (March 1st).
           */
          dayGenerator = Generators.byYearDayGenerator(byYearDay, start);
          break;
        }
        // $FALL-THROUGH$
      case MONTHLY:
        if (byMonthDay.length > 0) {
          /*
           * The BYMONTHDAY rule part specifies a COMMA separated list of days of
           * the month. Valid values are 1 to 31 or -31 to -1. For example, -10
           * represents the tenth to the last day of the month.
           */
          dayGenerator = Generators.byMonthDayGenerator(byMonthDay, start);
          byMonthDay = NO_INTS;
        } else if (byWeekNo.length > 0 && Frequency.YEARLY == freq) {
          /*
           * The BYWEEKNO rule part specifies a COMMA separated list of ordinals
           * specifying weeks of the year. This rule part is only valid for YEARLY
           * rules.
           */
          dayGenerator = Generators.byWeekNoGenerator(byWeekNo, wkst, start);
          byWeekNo = NO_INTS;
        } else if (byDay.length > 0) {
          /*
           * Each BYDAY value can also be preceded by a positive (n) or negative
           * (-n) integer. If present, this indicates the nth occurrence of the
           * specific day within the MONTHLY or YEARLY RRULE. For example, within
           * a MONTHLY rule, +1MO (or simply 1MO) represents the first Monday
           * within the month, whereas -1MO represents the last Monday of the
           * month. If an integer modifier is not present, it means all days of
           * this type within the specified frequency. For example, within a
           * MONTHLY rule, MO represents all Mondays within the month.
           */
          dayGenerator = Generators.byDayGenerator(
              byDay, Frequency.YEARLY == freq && byMonth.length == 0, start);
          byDay = NO_DAYS;
        } else {
          if (Frequency.YEARLY == freq) {
            monthGenerator = Generators.byMonthGenerator(
                new int[] { dtStart.month() }, start);
          }
          dayGenerator = Generators.byMonthDayGenerator(
              new int[] { dtStart.day() }, start);
        }
        break;
    }

    if (secondGenerator == null) {
      secondGenerator = Generators.bySecondGenerator(bySecond, start);
    }
    if (minuteGenerator == null) {
      if (byMinute.length == 0 && freq.compareTo(Frequency.MINUTELY) < 0) {
        minuteGenerator = Generators.serialMinuteGenerator(1, dtStart);
      } else {
        minuteGenerator = Generators.byMinuteGenerator(byMinute, start);
      }
    }
    if (hourGenerator == null) {
      if (byHour.length == 0 && freq.compareTo(Frequency.HOURLY) < 0) {
        hourGenerator = Generators.serialHourGenerator(1, dtStart);
      } else {
        hourGenerator = Generators.byHourGenerator(byHour, start);
      }
    }

    if (dayGenerator == null) {
      boolean dailyOrMoreOften = freq.compareTo(Frequency.DAILY) <= 0;
      if (byMonthDay.length > 0) {
        dayGenerator = Generators.byMonthDayGenerator(byMonthDay, start);
        byMonthDay = NO_INTS;
      } else if (byDay.length > 0) {
        dayGenerator = Generators.byDayGenerator(
            byDay, Frequency.YEARLY == freq, start);
        byDay = NO_DAYS;
      } else if (dailyOrMoreOften) {
        dayGenerator = Generators.serialDayGenerator(
            Frequency.DAILY == freq ? interval : 1, dtStart);
      } else {
        dayGenerator = Generators.byMonthDayGenerator(
            new int[] { dtStart.day() }, start);
      }
    }

    if (byDay.length > 0) {
      filters.add(Filters.byDayFilter(byDay, Frequency.YEARLY == freq, wkst));
      byDay = NO_DAYS;
    }

    if (byMonthDay.length > 0) {
      filters.add(Filters.byMonthDayFilter(byMonthDay));
    }

    //generator inference common to all periods
    if (byMonth.length > 0) {
      monthGenerator = Generators.byMonthGenerator(byMonth, start);
    } else if (monthGenerator == null) {
      monthGenerator = Generators.serialMonthGenerator(
          freq == Frequency.MONTHLY ? interval : 1, dtStart);
    }

    /*
     * The condition tells the iterator when to halt. The condition is
     * exclusive, so the date that triggers it will not be included.
     */
    Predicate<DateValue> condition;
    boolean canShortcutAdvance = true;
    if (count != 0) {
      condition = Conditions.countCondition(count);
      
      /*
       * We can't shortcut because the countCondition must see every generated
       * instance.
       * 
       * TODO(msamuel): If count is large, we might try predicting the end date
       * so that we can convert the COUNT condition to an UNTIL condition.
       */
      canShortcutAdvance = false;
    } else if (untilUtc != null) {
      if ((untilUtc instanceof TimeValue) != (dtStart instanceof TimeValue)) {
        // TODO(msamuel): warn
        if (dtStart instanceof TimeValue) {
          untilUtc = TimeUtils.dayStart(untilUtc);
        } else {
          untilUtc = TimeUtils.toDateValue(untilUtc);
        }
      }
      condition = Conditions.untilCondition(untilUtc);
    } else {
      condition = Predicates.<DateValue>alwaysTrue();
    }

    //combine filters into a single function
    Predicate<? super DateValue> filter;
    switch (filters.size()) {
      case 0:
        filter = Predicates.<DateValue>alwaysTrue();
        break;
      case 1:
        filter = filters.get(0);
        break;
      default:
        filter = Predicates.and(filters);
        break;
    }

    Generator instanceGenerator;
    if (bySetPos.length > 0) {
      instanceGenerator = InstanceGenerators.bySetPosInstanceGenerator(
          bySetPos, freq, wkst, filter,
          yearGenerator, monthGenerator, dayGenerator, hourGenerator,
          minuteGenerator, secondGenerator);
    } else {
      instanceGenerator = InstanceGenerators.serialInstanceGenerator(
          filter, yearGenerator, monthGenerator, dayGenerator,
          hourGenerator, minuteGenerator, secondGenerator);
    }

    return new RRuleIteratorImpl(
        dtStart, tzid, condition, instanceGenerator,
        yearGenerator, monthGenerator, dayGenerator,
        hourGenerator, minuteGenerator, secondGenerator,
        canShortcutAdvance);
  }

  /**
   * Generates a recurrence iterator that iterates over the union of the given
   * recurrence iterators.
   * @param first the first recurrence iterator
   * @param rest the other recurrence iterators
   * @return the union iterator
   */
  public static RecurrenceIterator join(
      RecurrenceIterator first, RecurrenceIterator... rest) {
    List<RecurrenceIterator> all = new ArrayList<RecurrenceIterator>();
    all.add(first);
    all.addAll(Arrays.asList(rest));
    return new CompoundIteratorImpl(
        all, Collections.<RecurrenceIterator>emptyList());
  }

  /**
   * <p>
   * Generates a recurrence iterator that iterates over all the dates in a
   * {@link RecurrenceIterator}, excluding those dates found in another
   * {@link RecurrenceIterator} (i.e. inclusions - exclusions).
   * </p>
   * <p>
   * Exclusions trump inclusions, and {@link DateValue dates} and
   * {@link DateTimeValue date-times} never match one another.
   * </p>
   * @param included the dates to include
   * @param excluded the dates to exclude
   * @return the resultant iterator
   */
  public static RecurrenceIterator except(
      RecurrenceIterator included, RecurrenceIterator excluded) {
    return new CompoundIteratorImpl(
        Collections.<RecurrenceIterator>singleton(included),
        Collections.<RecurrenceIterator>singleton(excluded));
  }

  private static final Pattern FOLD = Pattern.compile("(?:\\r\\n?|\\n)[ \t]");
  private static final Pattern NEWLINE = Pattern.compile("[\\r\\n]+");
  private static final Pattern RULE = Pattern.compile(
      "^(?:R|EX)RULE[:;]", Pattern.CASE_INSENSITIVE);
  private static final Pattern DATE = Pattern.compile(
      "^(?:R|EX)DATE[:;]", Pattern.CASE_INSENSITIVE);
  private static IcalObject[] parseContentLines(
      String rdata, TimeZone tzid, boolean strict)
      throws ParseException {
    String unfolded = FOLD.matcher(rdata).replaceAll("").trim();
    if ("".equals(unfolded)) { return new IcalObject[0]; }
    String[] lines = NEWLINE.split(unfolded);
    IcalObject[] out = new IcalObject[lines.length];
    int nbad = 0;
    for (int i = 0; i < lines.length; ++i) {
      String line = lines[i].trim();
      try {
        if (RULE.matcher(line).find()) {
          out[i] = new RRule(line);
        } else if (DATE.matcher(line).find()) {
          out[i] = new RDateList(line, tzid);
        } else {
          throw new ParseException(lines[i], i);
        }
      } catch (ParseException ex) {
        if (strict) {
          throw ex;
        }
        LOGGER.log(Level.SEVERE,
                   "Dropping bad recurrence rule line: " + line, ex);
        ++nbad;
      } catch (IllegalArgumentException ex) {
        if (strict) {
          throw ex;
        }
        LOGGER.log(Level.SEVERE,
                   "Dropping bad recurrence rule line: " + line, ex);
        ++nbad;
      }
    }
    if (nbad > 0) {
      IcalObject[] trimmed = new IcalObject[out.length - nbad];
      for (int i = 0, k = 0; i < trimmed.length; ++k) {
        if (out[k] != null) { trimmed[i++] = out[k]; }
      }
      out = trimmed;
    }
    return out;
  }

  /**
   * <p>
   * Creates an optimized version of an array based on the given BYSETPOS
   * array.
   * </p>
   * <p>
   * For example, given the array <code>BYMONTH=2,3,4,5</code> and a BYSETPOS
   * of <code>BYSETPOS=1,-1</code>, this method will return
   * <code>BYMONTH=2,5</code>.
   * </p>
   * @param members the array to optimize
   * @param bySetPos the BYSETPOS array
   * @return the optimized array
   */
  private static int[] filterBySetPos(int[] members, int[] bySetPos) {
    members = Util.uniquify(members);
    IntSet iset = new IntSet();
    for (int pos : bySetPos) {
      if (pos == 0) { continue; }
      if (pos < 0) {
        pos += members.length;
      } else {
        --pos;  // Zero-index.
      }
      if (pos >= 0 && pos < members.length) {
        iset.add(members[pos]);
      }
    }
    return iset.toIntArray();
  }

  private static final int[] NO_INTS = new int[0];
  private static final ByDay[] NO_DAYS = new ByDay[0];

  private RecurrenceIteratorFactory() {
    // uninstantiable
  }

}
